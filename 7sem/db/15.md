[К списку вопросов](db_exam.md)

# 15. Транзакции в СУРБД. Блокировки. Свойства блокировок. Виды гранулярности блокировок. Режимы блокировок. Взаимоблокировки. Обнаружение взаимоблокировок и выбор жертвы в СУБД.

## Транзакция
это объект, группирующий последовательность операций, которые должны быть выполнены как единое целое. Обеспечивает переход БД из одного целостного состояния в другое.

* Обеспечивают целостность БД в условиях:
	* Параллельной обработки данных
	* Физических отказов диска
	* Аварийного сбоя электропитания
	* И других
* Обладают 4 характеристиками, удовлетворяющими парадигме ACID:

1. Atomic – атомарные;
2. Consistent – согласованные;
3. Isolated – изолированные;
4. Durable – долговечные, устойчивые.

## ACID – Атомарность транзакций
Транзакция должна представлять собой атомарную (неделимую)
единицу работы;
* Должны быть выполнены либо все операции, входящие в
транзакцию, либо ни одна из них;
* Следовательно, в случае невозможности выполнить все
операции, все внесённые изменения должны быть отменены:
* Commit – совершение транзакции
* Rollback – отмена транзакции

## ACID – Согласованность транзакций

По завершению транзакции все данные должны остаться в
согласованном состоянии
* При выполнении транзакции необходимо выполнить все правила
реляционной СУБД:
* Проверки выполнения ограничений (домены, индексы уникальности,
внешние ключи, проверки, правила и т.д.)
* Обновление индексов;
* Выполнение триггеров
* И другие

## ACID – Изоляция транзакций
Изменения в данных, выполняемые в пределах транзакции, должны быть изолированы от всех изменений, выполняемых в других транзакциях, до тех пор, пока транзакция не совершена;
Выделяют различные уровни изоляции – для достижения компромисса между степенью распараллеливания работы с БД и строгостью выполнения принципа непротиворечивости:
* Чем выше уровень изоляции, тем выше степень непротиворечивости данных;
* Чем выше уровень изоляции, тем ниже степень распараллеливания и тем ниже степень доступности данных.

Стандартная классификация проблем с уровнями изоляции:
* P1: dirty read – «грязное» чтение 
* P2: non-repeatable read – невоспроизводимое чтение 
* P3: phantom read – фантомное чтение

### P1 (dirty read, «грязное» чтение) 
Транзакция Т1 вносит изменения в ряд таблицы. \
Т2 читает этот ряд после внесения изменений Т1, но до совершения Т1. \
Если Т1 будет отменена, то данные, считанные Т2, будут некорректными.

```postgresql
SELECT Age 
FROM Users
WHERE Id = 1;

SELECT Age 
FROM Users
WHERE Id = 1;

UPDATE Users
SET AGE = 21
WHERE Id = 1;

ROLLBACK;
```

### P2 (non-repeatable read, невоспроизводимое чтение)
Транзакция Т1 читает ряд. \
Транзакция Т2 после этого вносит изменения в этот ряд или удаляет его. \ 
Если Т1 после этого считает этот же ряд снова, то получит новый результат по сравнению с первым считыванием.

```postgresql
SELECT * FROM Users
WHERE Id = 1;

SELECT * FROM Users
WHERE Id = 1;

COMMIT;

UPDATE Users
SET AGE = 21
WHERE Id = 1;

COMMIT;
```

### P3 (phantom, фантомное чтение)
Транзакция Т1 читает набор рядов N, удовлетворяющих некоторому условию. \
После этого Т2 выполняет SQL запросы, создающие новые ряды, удовлетворяющие этому условию. \
Если Т1 повторит запрос с тем же условием, то получит другой набор рядов

```postgresql
SELECT * FROM Users
WHERE Age BETWEEN 10 AND 30;
SELECT * FROM Users
WHERE Age BETWEEN 10 AND 30; 

COMMIT;
INSERT INTO Users (Name, Age)
VALUES (‘Bob’, 27)

COMMIT;
```

## Блокировки в транзакциях

Транзакция может запрашивать блокировки различных ресурсов: строк, страниц, таблиц \
Блокировка не дает другим транзакциям изменять ресурсы \
Блокировка снимается после завершения транзакции

Это механизм достижения требуемого уровня изоляции \
Это механизм синхронизации при одновременном доступе к одному фрагменту данных

Блокировки устанавливаются в процессе выполнения транзакции и снимаются после её завершения[^1].

### Виды гранулярности блокировок.
На уровне таблицы \
На уровне страницы \
На уровне ряда

## Взаимоблокировки (deadlocks)

Возникают тогда, когда одна из транзакций не может завершить свои действия, поскольку вторая транзакция заблокировала нужные ей ресурсы, а вторая в то же время ожидает освобождения ресурсов первой транзакцией

Если в СУБД не установлен таймаут для ожидаения блокировок, такая ситуация приводит к бесконечному ожиданию:

В MS SQL: `SET LOCK_TIMEOUT timeout_period_ms`
- 1 - не ограничено, 
- 0 – ожидание отсутствует

`@@LOCK_TIMEOUT` хранит значение для текущего сеанса

### Пример взаимоблокировки
Транзакция А создает совмещаемую блокировку строки 1. \
Транзакция Б создает совмещаемую блокировку строки 1. \
Транзакция А теперь запрашивает монопольную блокировку строки 1 и блокируется до того, как транзакция Б закончится и освободит общую блокировку строки 1. \
Транзакция Б теперь запрашивает монопольную блокировку строки 1 и блокируется до того, как транзакция A закончится и освободит общую блокировку строки 1.

## Режимы блокировок

- Совмещаемая – S (shared)
- Блокировка обновления – U (update)
- Монопольная – X (exclusive)
- Блокировка с намерением – IS, IX, SIX (intent)
- Блокировка схемы – Sch-S, Sch-M
- Блокировка массового обновления – BU (bulk update)
- Диапазон ключей

## Выбор жертвы в СУБД

По умолчанию в качестве жертвы взаимоблокировки выбирается сеанс, выполняющий ту транзакцию, откат которой потребует меньше всего затрат. 

В качестве альтернативы пользователь может указать приоритет сеансов, используя инструкцию `SET DEADLOCK_PRIORITY { LOW | NORMAL | HIGH | [-10...10] }`. 

По умолчанию `DEADLOCK_PRIORITY = NORMAL`. 

Если у двух сеансов имеются различные приоритеты, то в качестве жертвы взаимоблокировки будет выбран сеанс с более низким приоритетом. 

Если у обоих сеансов установлен одинаковый приоритет, то в качестве жертвы взаимоблокировки будет выбран сеанс, откат которого потребует наименьших затрат. 

Если сеансы, вовлеченные в цикл взаимоблокировки, имеют один и тот же приоритет и одинаковую стоимость, то жертва взаимоблокировки выбирается случайным образом.

## Обнаружение взаимоблокировки 
выполняется потоком диспетчера блокировок, который периодически производит поиск по всем задачам в экземпляре компонента Database Engine. Процесс поиска:
- Значение интервала поиска по умолчанию составляет 5 секунд.
- Если диспетчер блокировок находит взаимоблокировки, интервал обнаружения взаимоблокировок снижается с 5 секунд до 100 миллисекунд в зависимости от частоты взаимоблокировок.
- Если поток диспетчера блокировки прекращает поиск взаимоблокировок, компонент Database Engine увеличивает интервал до 5 секунд.

[^1]: При откате до точки сохранения снимаются блокировки, установленные после этой точки