[К списку вопросов](db_exam.md)

# 13. Индексы в СУРБД. Принцип работы. Достоинства и недостатки. Влияние на производительность запросов. Применение индексов на практике. Покрывающий индекс.

## Индексы

Индекс – это структура для хранения информации, позволяющей быстро находить записи таблицы.

Пример в жизни: библиотека.

- Запись в индексе содержит:
  - Значения проиндексированных столбцов некоторой записи проиндексированной таблицы
  - Cсылку на искомую запись проиндексированной таблицы
- Записи в индексе упорядочены
- Алгоритм упорядочивания – обычно B-Tree, но также доступны Hash, GiST, SP-GiST, GIN и BRIN


- B-Tree – метод индексирования по умолчанию, подойдёт в большинстве случаев
- Hash – для точного сравнения, могут быть быстрее B-Tree, но до 10 версии лучше не использовать
- GiST – когда данные пересекаются в том же столбце, но другом ряду. Строит B-дерево, но поддерживает больше операций сравнения. Используется для геометрических типов и полнотекстового поиска
- SP-GiST – тоже хорош для геометрических типов, но для некоторых видов распределения значений
- GIN (Generalized Inverted Indexes) – для составных типов. Хороши для индексирования массивов и реализации полнотекстового поиска
- BRIN – для больших объёмов данных, где значения формируют последовательность

**Синтаксис:**
```postgresql
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ name ] ON table [ USING method ]
    ( { column | ( expression ) } [ COLLATE collation ] [ opclass ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( storage_parameter = value [, ... ] ) ]
    [ TABLESPACE tablespace ]
    [ WHERE predicate ]
```

CREATE INDEX создаёт индексы по указанному столбцу(ам) заданного отношения, которым может быть таблица или материализованное представление. Индексы применяются в первую очередь для оптимизации производительности базы данных (хотя при неправильном использовании возможен и противоположный эффект).

PostgreSQL поддерживает несколько типов индексов: B-дерево, хеш, GiST, SP-GiST, GIN и BRIN. Для разных типов индексов применяются разные алгоритмы, ориентированные на определённые типы запросов. По умолчанию команда CREATE INDEX создаёт индексы-B-деревья, эффективные в большинстве случаев. Выбрать другой тип можно, написав название типа индекса после ключевого слова USING. Например, создать хеш-индекс можно так:
```postgresql
CREATE INDEX имя ON таблица USING HASH (столбец);
```

## Влияние на производительность запросов

Для индексов-B-деревьев в таблицах, где ожидается множество добавлений и/или изменений записей, имеет смысл выбрать меньшие значения фактора заполнения в момент выполнения CREATE INDEX (до массовой загрузки данных в таблицы). Значения в диапазоне 50 – 90 могут сгладить всплески разделений страниц на начальном этапе жизни индекса-B-дерева (при подобном снижении фактора заполнения может даже уменьшиться абсолютное количество разделений страниц, хотя это во многом зависит от нагрузки). Процедура восходящего удаления индексных кортежей, описанная в Подразделе 64.4.2, рассчитывает на наличие некоторого «дополнительного» места на страницах, где будут сохраняться «дополнительные» версии кортежей, и следовательно, может зависеть от фактора заполнения (хотя обычно его влияние второстепенно).

В других особых случаях может быть полезно увеличить фактор заполнения до 100 перед выполнением CREATE INDEX, чтобы максимально эффективно использовать хранилище. Этот вариант следует рассматривать, только если вы абсолютно уверены, что таблица будет статичной (то есть в ней никогда не будут изменяться или добавляться данные). В противном случае фактор заполнения, равный 100, скорее повредит производительности — даже единичные изменения или добавления вызовут резкий скачок активности разделения страниц.

Сбалансированное дерево состоит из: 
- корневого узла (root node), содержащего одну страницу, 
- нескольких промежуточных уровней (intermediate levels), содержащих дополнительные страницы
- листового уровня (leaf level).

На страницах листового уровня находятся отсортированные элементы, соответствующие индексируемым данным. По мере добавления данных в таблицу индекс будет разрастаться, но по-прежнему оставаться в форме сбалансированного дерева

- Скорость поиска листа с данными не зависит от ключа, по которому осуществляется поиск
- Все листья равноудалены от корневого узла

Визуализация [тут](https://www.cs.usfca.edu/~galles/visualization/BTree.html)

Подробнее [тут](https://postgrespro.ru/docs/postgresql/14/indexes-types), [тут](https://postgrespro.ru/docs/postgresql/14/sql-createindex) и [тут](https://docs.google.com/presentation/d/1swHdbjobD9JmGFpILCnE0-dJFvpxCDyh/edit#slide=id.p58)

## Применение индексов на практике

Создание уникального индекса-B-дерева по столбцу title в таблице films:
```postgresql
CREATE UNIQUE INDEX title_idx ON films (title);
```
Создание уникального индекса-B-дерева по столбцу title с неключевыми столбцами director и rating в таблице films:
```postgresql
CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);
```
Создание индекса B-дерево без исключения дубликатов:
```postgresql
CREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);
```
Создание индекса по выражению lower(title), позволяющего эффективно выполнять регистронезависимый поиск:
```postgresql
CREATE INDEX ON films ((lower(title)));
```
(В этом примере мы решили опустить имя индекса, чтобы имя выбрала система, например films_lower_idx.)

Создание индекса с нестандартным правилом сортировки:
```postgresql
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
```
Создание индекса с нестандартным порядком значений NULL:
```postgresql
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
```
Создание индекса с нестандартным фактором заполнения:
```postgresql
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
```
Создание индекса GIN с отключённым механизмом быстрого обновления:
```postgresql
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
```
Создание индекса по столбцу code в таблице films и размещение его в табличном пространстве indexspace:
```postgresql
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
```
Создание индекса GiST по координатам точек, позволяющего эффективно использовать операторы box с результатом функции преобразования:
```postgresql
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) && '(0,0),(1,1)'::box;
```
Создание индекса без блокировки записи в таблицу:
```postgresql
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
```

Подробнее [тут](https://postgrespro.ru/docs/postgresql/14/sql-createindex)

## Составные индексы (покрывающий индекс)
Индексы можно создавать и по нескольким столбцам таблицы. Например, если у вас есть таблица:
```postgresql
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
```
(предположим, что вы поместили в неё содержимое каталога /dev) и вы часто выполняете запросы вида:
```postgresql
SELECT name FROM test2 WHERE major = константа AND minor = константа;
```
тогда имеет смысл определить индекс, покрывающий оба столбца major и minor. Например:
```postgresql
CREATE INDEX test2_mm_idx ON test2 (major, minor);
```

В настоящее время составными могут быть только индексы типов B-дерево, GiST, GIN и BRIN. Возможность построения индекса по нескольким ключевым столбцам не зависит от возможности добавления в индекс неключевых столбцов (INCLUDE). Число столбцов в индексе ограничивается 32, включая столбцы INCLUDE. (Этот предел можно изменить при компиляции PostgreSQL; см. файл pg_config_manual.h.)

Подробнее [тут](https://postgrespro.ru/docs/postgresql/14/indexes-multicolumn)
