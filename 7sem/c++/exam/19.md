[К списку вопросов](exam_oop.md)

# 19. Множественное наследование. Прямая и косвенная базы. Виртуальное наследование. Понятие доминирования. Порядок создания и уничтожения объектов. Проблемы множественного наследования. Неоднозначности при множественном наследовании.

ООП использует рекурсивный дизайн – постепенное разворачивание программы от базовых классов к более специализированным. С++ один из немногих языков с множественным наследованием. Оно может упростить граф наследования, но также создает пучок проблем для программиста: возникает неоднозначность, которую бывает тяжело контролировать.

```cpp
class A
{
public: 
 int a; // объявление публичного поля!
 int (*b)(); //указатель на функцию! тоже публичное поле!
             //более того, указателей на ФУНКЦИИ ВООБЩЕ не должно быть! максимум - на методы
 int f();
 int f(int);
 int g();
}
 
class B
{
int a; //допускается - приватные поля 
int b; 
public: 
 int f();
 int g; // публичное свойство!
 int h();
 int h(int);
}
 
class C: public A, public B {};
 
//метод рандомного класса
X::f(C *pc)
{
pc->a = 1; //error! ошибка доступа 
pc->b(); //то же самое! 
pc->f(); //йух пойми какой Ф вызывать, то ли из А, толи из Б 
pc->f(1) //перегрузка не произойдёт 
pc->g = 1; //функция или переменная!? 
pc->h(); 
pc->h(1); //а вот в этих двух всё ок 
}
```

Патовая ситуация – если не мы писали А и В, но пытаемся объединить их в один свой. В С можно было бы доминантно определить новые методы взамен старых, но члены классов всё равно будут пересекаться. Также, иерархия наследования при множественном наследовании может быть достаточно сложной. Введем понятие «прямой базы» - от которой НЕПОСРЕДСТВЕННО наследуется новый класс, и «косвенной базы» - прямая база прямой базы и так далее. В производный класс прямая база может входить только один раз, а косвенная – сколько угодно раз. Тем не менее, желательно, чтобы база входила только один раз. Для этого используется «виртуальное наследование». Если подобъект класса был создан, идет проверка на это, и ещё раз он не создается. Виртуальные базы при множественном наследовании отрабатывают в первую очередь слева направо, а потом остальные базы.

Virtual – включает механизм контроля, что класс уже создан.

Доминирование – такие методы в производном классе доминируют над базовыми.

```cpp
class A {};
class B: virtual public A {};
class C: public A {};
class D: public B, public C {};
```

Здесь в примере все ок. При создании подобъекта класса B для класса D, отработает механизм виртуальности для подобъекта класса A, и уже при создании подобъекта класса C, не будет создавать для него подобъект класса A, а произойдет связывание с тем подобъектом А, который уже был создан.

```cpp
class A {};
class B: public A {};
class C: virtual public A {};
class D: public B, public C {};
```

Не всё ок, тк подобъект класса А будет включен два раза в класс D. Для подобъекта класса В будет создан подобъект А. Если в В и С будут функции, меняющие что-то в А, то эти изменения будут происходить независимо друг от друга. Поэтому лучше писать виртуал и там и тут – предохранения ради. Если в А будет f() и в B будет f(); то при вызове f() из Д вызовется доминирующий – из В. Такое правило, что тот метод, который находится в иерархии ниже, он подменяет те методы которые находятся выше. в данным случае класс В, подменяет метод класса А. (разговор про метод f())

```cpp
class A {f();};
class B: virtual public A {f();};
class C: public B, virtual public A {};
```

Интерпретируется по-разному в зависимости от компилятора (неопределенной поведение).

В билдере для С будет вызываться B::f(); в визуале – неоднозначность.

Проблемы при множественном наследовании (на примере):

Предположим, есть некоторые визуализированные объекты, которые можно нарисовать.

```cpp
class W
{
public:
void draw();
};
class B: virtual public W
{
public:
void draw() {W::draw(); /*...*/};
};
class M: virtual public W
{
public:
void draw() {W::draw(); /*...*/};
};
class MB: virtual public W
{
public:
void draw() {M::draw(); B::draw(); /*...*/};
};
```

При отрисовке МБ ДВАЖДЫ отрисуется W – что не есть торт. Для этого в раздел протектеда добавляют _draw(); - то же имя но с подчерком. W::_draw будет рисовать ТОЛЬКО W, B::_draw – ТОЛЬКО В. Соответственно, в МВ надо будет по отдельности вызывать W::_draw, B::_draw, M::_draw. Неудобно, но безвыходно. (Проблема множественного вызова базового класса)

Неоднозначность при множественном наследовании:

```cpp
class A
{
public:  
 int a;
 int (*b)();
 int f();
 int f(int);
 int g();
};
 
class B
{
int a;  
int b;  
public:  
 int f();
 int g;
 int h();
 int h(int);
};
 
class C: public A, public B
{
};
 
class D
{
public:
static void fun(C& obj)
{ 
 obj.a = 1; // Error!!! (проверка на уровень доступа происходит после проверки на неоднозначность)
 obj.b(); // Error!!! (проверка на тип происходит после проверки на неоднозначность)
 obj.f(); // Error!!!
 obj.f(1); // Error!!!
 obj.g = 1; // Error!!!
 obj.h(); obj.h(1); // Ok!
}
};
 
void main()
{
C obj;
D::fun(obj); 
}
```

Как это исправить: Подменить все, что находится в базовых классах в производном классе.
Создание объектов:

```cpp
class A
class B : public A
class C : public B
```

Для последнего: created A, created B, created C, destroyed C, destroyed B, destroyed A