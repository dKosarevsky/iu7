[К списку вопросов](exam_oop.md)

# 18. Наследование в С++. Построение иерархии классов. Выделение общей части группы классов. Расщепление классов.

**Наследование** – «надстройка» нового функционала над старым, не изменяя его; создание нового класса на основе старого. Существует три схемы наследование: private, protected, public. Уровень доступа производного класса будет зависеть от схемы наследования. По умолчанию схема наследования private.

```cpp
class A2  
 
{
 
private:
 
int a;
 
protected:
 
int b;
 
public:  
 
int f();
 
}  
 
class B2: :/*private V protected V public*/ public A2  
 
{
 
private:
 
int c;
 
protected:
 
int d;
 
public:
 
int g();
 
}
```

B obj;
// объяснение найдено на просторах гита по лекциям Тассова
/* приватное наследованиеа не наследуется. c, b, f- приватные, d - протектная, g - публичнаяизвне можно получить доступ только к g (интерфейсу). Г имеет доступ к d,c,b,f. Ф имеет доступ к b,aпроисходит смена интерфейса Ф на Гпротектное наследованиеа не наследуется. c - приватная, b,d,f - протектные, g - публичная-''-.смена интерфейса, но в данном случае интерфейс Ф БУДЕТ ДОСТУПЕН к классам, наследующимся из класса Бпубличное наследованиевсе члены сохраняют свой уровень доступа базового классаа не наследуется.c - приватная, b,d - протектные, f,g - публичные.интерфейс ДОПОЛНЯЕТСЯ.*/

Что происходит при схеме private: \
В современных языках наследование идет только по схеме public. Иные схемы наследования изменяют интерфейс, что противоречит основным идеям ООП (условно, добавлять функционал без изменения существующего кода). Все члены базового класса наследуются с уровнем доступа private. \
При схеме publiс все члены наследуются с их уровнем доступа. Методы произвольного класса будут подменять методы базового класса. \
При схеме protected члены public приобретают уровень protected. 

Итого: основной подход – это подмена: производный подменяет базу. Если мы начинаем расширять, то мы сразу наталкиваемся на проблемы подмены одного объекта на другой.

В производных классах мы можем в схемах наследования private или protected вернуть доступ к члену базового класса:
```cpp
class B3: /*private V protected V public*/ A2
{
    private:
            int c;
    protected:
        int d;
    public:
        int g();
        using A2::f; // при такой записи будет изменен уровень удоступа для всех методов с именем f
                     // это восстановление уровня доступа при схеме private и protected для члена базового класса
}
```
// Если нужно надстроить новый интерфейс поверх старого, закрыв что-то старое и перекрыв что-то новым, можно использовать кейворд using/

// В данном случае Б сможет использовать метод ф, несмотря на то что наследование – приватное. Тем не менее, ИЗВНЕ использовать pc->A::f() – это чрезвычайно не торт, нужно оборачивать в какой-нибудь другой метод.

Выделение общей части:
- Схожий набор свойств
- Общая схема использования
- Сходство реализации

Расщепление:
- Разное использование
- Несвязная реализация
- Класс оперирует в двух несвязных обсуждениях проекта

Набор классов, связанных отношением наследования, называют иерархией.

В производном классе можно определить тот же метод, что и в базовом. И этот метод в производном классе будет доминировать (то есть при вызове будет выполняться именно он).

Конструкторы базовых объектов вызываются в порядке наследования (от более базового к более специализированному), деструкторы в обратном.

С++ разрешает множественное наследование. Z наследует как от X, так и от Y class Z: public X, public Y

Возникают неоднозначности при существовании одинаковых членов. Стоит писать virtual при наследовании, что гарантирует переопределение и использование именно доминирующего члена.

Различают прямое (А наследуется от В) и косвенное (А наследуется от В, которое наследуется от С; А и С косвенные) наследование.
