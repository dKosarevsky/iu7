[К списку вопросов](exam_oop.md)

# 17. Создание и уничтожение объектов в С++. Конструкторы и деструкторы. Виды конструкторов. Раздел инициализации конструкторов. Способы создания объектов.

**Конструктор** — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса. Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию/пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса (например, открыть определенный файл или базу данных).
 
В отличие от обычных методов, конструкторы имеют определенные правила их именования:
   - конструкторы всегда должны иметь то же имя, что и класс (учитываются верхний и нижний регистры);
   - конструкторы не имеют типа возврата (даже void).

Обратите внимание, конструкторы предназначены только для выполнения инициализации. Не следует пытаться вызывать конструктор для повторной инициализации существующего объекта. Хотя это может скомпилироваться без ошибок, результаты могут получиться неожиданные (компилятор создаст временный объект, а затем удалит его).

## Конструкторы по умолчанию

Конструктор, который не имеет параметров (или содержит параметры, которые все имеют значения по умолчанию), называется **конструктором по умолчанию**. Он вызывается, если пользователем не указаны значения для инициализации. Например:

```cpp
#include <iostream>
 
class Fraction
{
private:
   int m_numerator;
   int m_denominator;
 
public:
   Fraction() // конструктор по умолчанию
   {
        m_numerator = 0;
        m_denominator = 1;
   }
 
   int getNumerator() { return m_numerator; }
   int getDenominator() { return m_denominator; }
   double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};
 
int main()
{
   Fraction drob; // так как нет никаких аргументов, то вызывается конструктор по умолчанию Fraction()
   std::cout << drob.getNumerator() << "/" << drob.getDenominator() << '\n';
 
   return 0;
}
```
 
## Конструкторы с параметрами
 
Хотя конструктор по умолчанию отлично подходит для обеспечения инициализации наших классов значениями по умолчанию, часто может быть нужно, чтобы экземпляры нашего класса имели определенные значения, которые мы предоставим позже. К счастью, конструкторы также могут быть объявлены с параметрами. 

Вот пример конструктора, который имеет два целочисленных параметра, которые используются для инициализации числителя и знаменателя:

```cpp 
#include <cassert>
 
class Fraction
{
private:
   int m_numerator;
   int m_denominator;
 
public:
   Fraction() // конструктор по умолчанию
   {
        m_numerator = 0;
        m_denominator = 1;
   }
 
   // Конструктор с двумя параметрами, один из которых имеет значение по умолчанию
   Fraction(int numerator, int denominator=1)
   {
       assert(denominator != 0);
       m_numerator = numerator;
       m_denominator = denominator;
   }
 
   int getNumerator() { return m_numerator; }
   int getDenominator() { return m_denominator; }
   double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};
```

Обратите внимание, теперь у нас есть два конструктора: конструктор по умолчанию, который будет вызываться, если мы не предоставим значения, и конструктор с параметрами, который будет вызываться, если мы предоставим значения. 

Эти два конструктора могут мирно сосуществовать в одном классе благодаря перегрузке функций. Фактически, вы можете определить любое количество конструкторов до тех пор, пока у них будут уникальные параметры (учитывается их количество и тип).
 
Как использовать конструктор с параметрами? Всё просто! Прямая инициализация:

```cpp 
int a(7); // прямая инициализация
Fraction drob(4, 5); // инициализируем напрямую, вызывается конструктор Fraction(int, int)
```

Здесь мы инициализировали нашу дробь числами 4 и 5, результат — 4/5!
 
В C++11 мы также можем использовать uniform-инициализацию:
 
```cpp
int a { 7 }; // uniform-инициализация
Fraction drob {4, 5}; // uniform-инициализация, вызывается конструктор Fraction(int, int)
```

Мы также можем указать только один параметр для конструктора с параметрами, а второе значение будет значением по умолчанию:
 
```cpp
Fraction seven(7); // вызывается конструктор Fraction(int, int), второй параметр использует значение по умолчанию
```

Значения по умолчанию для конструкторов работают точно так же, как и для любой другой функции, поэтому в вышеприведенном примере, когда мы вызываем seven(7), вызывается Fraction(int, int), второй параметр которого равен 1 (значение по умолчанию).
 
**Правило**: Используйте прямую инициализацию или uniform-инициализацию с объектами ваших классов.
 
**Копирующая инициализация**
 
Подобно обычным переменным, классы также можно инициализировать, используя копирующую инициализацию:
 
```cpp
int a = 7; // копирующая инициализация
Fraction eight = Fraction(8); // копирующая инициализация, вызывается Fraction(8, 1)
Fraction nine = 9; // копирующая инициализация. Компилятор будет искать пути конвертации 9 в Fraction, что приведет к вызову конструктора Fraction(9, 1)
```

Однако рекомендуется избегать этой формы инициализации классов, так как она может быть менее эффективной. Хотя uniform-инициализация, прямая и копирующая инициализации работают одинаково с фундаментальными типами данных, с классами это не совсем так (хотя конечный результат часто совпадает). 
 
**Правило**: Не используйте копирующую инициализацию с объектами ваших классов.
 
**Уменьшение количества конструкторов**

В примере с классом Fraction и двумя конструкторами (по умолчанию и с параметрами), конструктор по умолчанию на самом деле лишний. Мы могли бы упростить этот класс следующим образом:

```cpp 
#include <cassert>
 
class Fraction
{
private:
   int m_numerator;
   int m_denominator;
 
public:
   // Конструктор по умолчанию
   Fraction(int numerator=0, int denominator=1)
   {
       assert(denominator != 0);
       m_numerator = numerator;
       m_denominator = denominator;
   }
 
   int getNumerator() { return m_numerator; }
   int getDenominator() { return m_denominator; }
   double getValue() { return static_cast<double>(m_numerator) / m_denominator; }
};
```

Хотя этот конструктор по-прежнему является конструктором по умолчанию, он теперь определен таким образом, что может принимать одно или два значения, предоставленные пользователем:
 
```cpp
Fraction drob; // вызов Fraction(0, 1)
Fraction seven(7); // вызов Fraction(7, 1)
Fraction sixTwo(6, 2); // вызов Fraction(6, 2)
```

На практике старайтесь сокращать количество конструкторов вашего класса.
 
Неявно генерируемый конструктор по умолчанию
 
Если ваш класс не имеет конструкторов, то язык C++ автоматически сгенерирует для вашего класса открытый конструктор по умолчанию. Его иногда называют неявным конструктором (или «неявно сгенерированным конструктором»). Рассмотрим следующий класс:
 
```cpp
class Date
{
private:
   int m_day = 12;
   int m_month = 1;
   int m_year = 2018;
};
```

У этого класса нет конструктора, поэтому компилятор сгенерирует следующий конструктор:
 
```cpp
class Date
{
private:
   int m_day = 12;
   int m_month = 1;
   int m_year = 2018;
 
public:
   Date() // неявно генерируемый конструктор
   {
   }
};
```

Этот конструктор позволяет создавать объекты класса, но не выполняет их инициализацию и не присваивает значения членам класса.
 
Хотя вы не можете увидеть неявно сгенерированный конструктор, но его существование можно доказать:
 
```cpp
class Date
{
private:
   int m_day = 12;
   int m_month = 1;
   int m_year = 2018;
 
   // Не было предоставлено конструктора, поэтому C++ автоматически создаст открытый конструктор по умолчанию
};
 
int main()
{
   Date date; // вызов неявного конструктора
 
   return 0;
}
```

Вышеприведенный код скомпилируется, поскольку в объекте date сработает неявный конструктор (который является открытым). 

Если ваш класс имеет другие конструкторы, то неявно генерируемый конструктор создаваться не будет. Например:
 
```cpp
class Date
{
private:
   int m_day = 12;
   int m_month = 1;
   int m_year = 2018;
 
public:
   Date(int day, int month, int year) // обычный конструктор (не по умолчанию)
   {
       m_day = day;
       m_month = month;
       m_year = year;
   }
 
   // Неявный конструктор не создастся, так как мы уже определили свой конструктор
};
 
int main()
{
   Date date; // ошибка: Невозможно создать объект, так как конструктор по умолчанию не существует, и компилятор не сгенерировал неявный конструктор автоматически
   Date today(14, 10, 2020); // инициализируем объект today
 
   return 0;
}
```

Рекомендуется всегда создавать по крайней мере один конструктор в классе. Это позволит вам контролировать процесс создания объектов вашего класса, и предотвратит возникновение потенциальных проблем после добавления других конструкторов.
 
**Правило**: Создавайте хотя бы один конструктор в классе, даже если это пустой конструктор по умолчанию.
 
**Классы, содержащие другие классы**

Одни классы могут содержать другие классы в качестве переменных-членов. По умолчанию, при создании внешнего класса, для переменных-членов будут вызываться конструкторы по умолчанию. Это произойдет до того, как тело конструктора выполнится. 

Это можно продемонстрировать следующим образом:

```cpp 
#include <iostream>
 
class A
{
public:
   A() { std::cout << "A\n"; }
};
 
class B
{
private:
   A m_a; // B содержит A, как переменную-член
 
public:
   B() { std::cout << "B\n"; }
};
 
int main()
{
   B b;
   return 0;
}
```

Результат выполнения программы:

```shell
A
B
``` 

 
При создании переменной b вызывается конструктор B(). Прежде чем тело конструктора выполнится, m_a инициализируется, вызывая конструктор по умолчанию класса A. Таким образом выведется A. Затем управление возвратится обратно к конструктору B, и тело конструктора B начнет свое выполнение.
 
Здесь есть смысл, так как конструктор B() может захотеть использовать переменную m_a, поэтому сначала нужно инициализировать m_a!
 
## Деструкторы
Определяемый пользователем класс имеет конструктор, который обеспечивает надлежащую инициализацию. Для многих типов также требуется обратное действие. Деструктор обеспечивает соответствующую очистку объектов указанного типа. Имя деструктора представляет собой имя класса с предшествующим ему знаком «тильда» ~. Так, для класса X деструктор будет иметь имя ~X(). Многие классы используют динамическую память, которая выделяется конструктором, а освобождается деструктором.

```cpp
class date
{
  int day, year;
  char *month;
public:
  date(int d, char* m, int y)
  {
    day = d;
    month = new char[strlen(m)+1];
    strcpy_s(month, strlen(m)+1,m);
    year = y;
  }
  ~date() { delete[] month; } // деструктор
};
```
