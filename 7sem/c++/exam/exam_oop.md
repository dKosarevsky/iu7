1. Структурное программирование: нисходящая разработка, использование базовых логических структур, сквозной структурный контроль.
2. Преимущества и недостатки структурного и объектно-ориентированного программирования.
3. Основные понятия ООП: инкапсуляция, наследование, полиморфизм. Понятие объекта. Категории объектов. Отношения между объектами. Понятие класса. Отношения между классами. Понятие домена.
4. Цикл разработки ПО с использованием ООП: анализ, проектирование, эволюция, модификация. Рабочие продукты объектно-ориентированного анализа.
5. Концепции информационного моделирования. Понятие атрибута. Типы атрибутов. Правила атрибутов. Понятие связи. Типы связей. Формализация связей. Композиция связей. Подтипы и супертипы. Диаграмма сущность-связь.
6. Модель поведения объектов. Жизненный цикл и диаграмма перехода в состояния (ДПС). Виды состояний. События, данные событий. Действия состояний. Таблица перехода в состояния (ТПС). Правила переходов.
7. Модель взаимодействия объектов (МВО). Диаграмма взаимодействия объектов в подсистеме. Типы событий. Схемы управления. Имитирование. Каналы управления.
8. Диаграмма потоков данных действий (ДПДД). Типы процессов: аксессоры, генераторы событий, преобразования, проверки. Таблица процессов (ТП). Модель доступа к объектам (МДО).
9. Домены. Модели доменного уровня. Типы доменов. Мосты, клиенты, сервера.
10. Объектно-ориентированное проектирование. Диаграмма класса. Структура класса. Диаграмма зависимостей. Диаграмма наследования.
11. Архитектурный домен. Паттерн КМС. Шаблоны для создания прикладных классов.
12. Структурные паттерны: адаптер (Adapter), декоратор (Decorator), компоновщик (Composite), заместитель (Proxy), мост (Bridge), фасад (Facade).
13. Порождающие паттерны: одиночка (Singleton), фабричный метод (Factory Method), абстрактная фабрика (Abstract Factory), строитель (Builder), прототип (Prototype), пул объектов (Object Pool).
14. Паттерны поведения: стратегия (Strategy), команда (Command), цепочка обязанностей (Chain of Responsibility), подписчик-издатель (Publish-Subscribe), посредник (Mediator), посетитель (Visitor), опекун (Memento), шаблонный метод (Template Method), хранитель (Holder), итератор (Iterator), свойство (Property).
15. Структура программы на языках С и С++. Функции С и С++. Перегрузка функций в С++. Ссылки.
16. Классы и объекты в С++. Определение класса с помощью class, struct, union. Ограничение доступа к членам класса в С++. Члены класса и объекта. Методы. Константные члены. Схемы наследования.
17. Создание и уничтожение объектов в С++. Конструкторы и деструкторы. Виды конструкторов. Раздел инициализации конструкторов. Способы создания объектов.
18. Наследование в С++. Построение иерархии классов. Выделение общей части группы классов. Расщепление классов.
19. Множественное наследование. Прямая и косвенная базы. Виртуальное наследование. Понятие доминирования. Порядок создания и уничтожения объектов. Проблемы множественного наследования. Неоднозначности при множественном наследовании.
20. Полиморфизм в С++. Виртуальные методы. Виртуальные деструкторы. Чисто виртуальные методы. Понятие абстрактного класса. Ошибки возникающие при работе с указателем на базовый класс. Дружественные связи.
21. Обработка исключительных ситуаций в С++. Проблемы с динамической памятью при обработке исключительных ситуаций. Перегрузка операторов в С++. Правила перегрузки операторов. Операторы .*, ->*. Перегрузка унарных и бинарных операторов. Перегрузка оператора = : копирование, перенос. Перегрузка операторов ->, *, []. Перегрузка операторов ++, --. Операторы приведения типов.
22. Шаблоны функций и классов в С++. Параметры шаблонов. Специализация шаблонов частичная и полная. Параметры шаблона задаваемые по умолчанию. Шаблоны с переменным числом параметров. Пространства имен.
23. Приведение типа в С++: static_cast, dynamic_cast, const_cast, reinterpret_cast. «Умные указатели» в С++: unique_ptr, shared_ptr, weak_ptr. Контейнерные классы и итераторы. Работа с итераторами. Цикл for для работы с контейнерными объектами.