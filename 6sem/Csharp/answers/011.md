[Вернуться к списку вопросов](../questions.md)

<div id="begin"></div>
-----------------

# Вопрос № 11

* Конструкторы классов.
* Перегрузка конструкторов.
* Вызов перегруженного конструктора.
* Вызов конструктора базового класса.
* Статические конструкторы.
* Финализаторы классов.
* Области видимости конструкторов и финализаторов.

Конструкторы экземпляров используются для создания и инициализации переменных члена экземпляра, если создание объекта
class осуществляется с помощью выражения new. Для инициализации класса static или статических переменных в нестатическом
классе определяется статический конструктор.

В следующем примере показан конструктор экземпляра.

```cs
class Coords
{
    public int x, y;

    // constructor
    public Coords()
    {
        x = 0;
        y = 0;
    }
}
```

#### Примечание

Для ясности этот класс содержит открытые поля. Открытые поля не рекомендуется использовать на практике, поскольку в этом
случае любой метод в любом месте программы получает неограниченный и неконтролируемый доступ к внутренней работе
объекта. Члены данных обычно должны быть закрытыми, а доступ к ним должен осуществляться только посредством методов и
свойства класса.

Этот конструктор экземпляра вызывается каждый раз при создании объекта на базе класса Coords. Такой конструктор без
аргументов называется конструктором без параметров. Зачастую такие конструкторы используются для предоставления
дополнительных конструкторов. Например, можно добавить конструктор в класс Coords, позволяющий указывать начальные
значения для членов данных:

```cs
// A constructor with two arguments.
public Coords(int x, int y)
{
    this.x = x;
    this.y = y;
}
```

Это позволяет создавать объекты Coords с начальными значениями по умолчанию или с другими начальными значениями:

```cs
var p1 = new Coords();
var p2 = new Coords(5, 3);
```

Если класс не имеет конструктора, автоматически создается конструктор без параметров и для инициализации полей объекта
используются значения по умолчанию. Например, int инициализируется значением 0. Дополнительные сведения о значениях по
умолчанию типов см. в разделе Значения по умолчанию типов C#. Следовательно, поскольку конструктор без параметров класса
Coords инициализирует все члены данных с нулевыми значениями, его можно удалить. При этом работа класса не изменится.

Конструкторы экземпляров также можно использовать для вызова конструкторов экземпляров базового класса. Конструктор
класса может вызвать конструктор базового класса с помощью инициализатора:

```cs
class Circle : Shape
{
    public Circle(double radius)
        : base(radius, 0)
    {
    }
}
```

Статический конструктор используется для инициализации любых статических данных или для выполнения определенного
действия, которое требуется выполнить только один раз. Он вызывается автоматически перед созданием первого экземпляра
или ссылкой на какие-либо статические члены.

Статические конструкторы обладают следующими свойствами.

* Статический конструктор не принимает модификаторы доступа и не имеет параметров.
* Класс или структура могут иметь только один статический конструктор.
* Статические конструкторы не могут быть унаследованы или перегружены.
* Статический конструктор нельзя вызывать напрямую. Он предназначен только для вызова из общеязыковой среды выполнения (
  CLR). Он запускается автоматически.
* Пользователь не управляет временем, в течение которого статический конструктор выполняется в программе.
* Статический конструктор вызывается автоматически. Он инициализирует класс перед созданием первого экземпляра или
  ссылок на какие-либо статические элементы. Статический конструктор выполняется раньше, чем конструктор экземпляра.
  Статический конструктор типа вызывается при вызове статического метода, назначенного делегату или событию, а не при
  его назначении. Если в классе со статическим конструктором присутствуют инициализаторы переменных для статических
  полей, они выполняются в том порядке, в котором они появляются в объявлении класса. Эти инициализаторы выполняются
  непосредственно перед выполнением статического конструктора.
* Если вы не предоставили статический конструктор для инициализации статических полей, все статические поля
  инициализируются значениями по умолчанию (Значения по умолчанию типов C#).
* Если статический конструктор создает исключение, среда выполнения не вызывает его во второй раз, и тогда тип остается
  неинициализированным на все время существования домена приложения. Чаще всего исключение TypeInitializationException
  вызывается, когда статический конструктор не может создать экземпляр типа или в статическом конструкторе создается
  необработанное исключение. Для устранения неполадок со статическими конструкторами, которые не определены явным
  образом в исходном коде, может потребоваться проверка кода на промежуточном языке (IL).
* Наличие статического конструктора не позволяет добавлять атрибут типа BeforeFieldInit. Это ограничивает возможности
  оптимизации во время выполнения.
* Поле, объявленное как static readonly, может быть присвоено только при его объявлении или в статическом конструкторе.
  Если явный статический конструктор не требуется, инициализируйте статические поля в объявлении, а не через статический
  конструктор, чтобы оптимизировать среду выполнения.
* Среда выполнения вызывает статический конструктор не более одного раза для каждого домена приложения. Этот вызов
  выполняется в заблокированном регионе на основе определенного типа класса. В тексте статического конструктора не нужны
  дополнительные механизмы блокировки. Чтобы избежать риска взаимоблокировки, не блокируйте текущий поток в статических
  конструкторах и инициализаторах. Например, не следует ожидать выполнения задач, потоков, обработчиков ожидания или
  событий, а также создавать блокировки или выполнять блокирующие параллельные операции, как, например, параллельные
  циклы, Parallel.Invoke и запросы Parallel LINQ.

### Использование

* Типичным использованием статических конструкторов является случай, когда класс использует файл журнала и конструктор
  применяется для добавления записей в этот файл.
* Статические конструкторы также полезны при создании классов-оболочек для неуправляемого кода, когда конструктор может
  вызвать метод LoadLibrary.
* Кроме того, статические конструкторы очень удобны для проведения проверок времени выполнения для параметров типов,
  которые нельзя проверить во время компиляции с помощью ограничений параметров типов.

### Финализаторы

Перед тем, как объект будет удален из памяти запускается его финализатор, если он определен. Финализаторы объявляются
как конструкторы, но с префиксом ~. Финализатор не может быть public или static, не может принимать параметры и
обращаться к базовому классу.

Сборка мусора проходит несколько фаз. Сначала сборщик мусора идентифицирует неиспользуемые объекты готовые к удалению.
Объекты без финализаторов удаляются сразу. Объекты с финализаторами сохраняются в активном состоянии и помещаются в
специальную очередь. На этом сборка мусора завершается и программа продолжает выполнение. При этом параллельно начинает
выполняться поток финализации, выбирая объекты из указанной очереди и запуская их методы финализации. Перед запуском
финализатора объект по прежнему активен — очередь действует в качестве корня. После того как объект извлечен из очереди,
а его финализатор выполнен, объект становится недоступным и будет удален при следующей сборке мусора.

Финализаторы могут быть полезны, но есть ряд отрицательных моментов в их использовании:

* финализаторы замедляют выделение и утилизацию памяти
* финализаторы продлевают время жизни объектов (а также ссылающихся на них объектов)
* порядок вызова финализаторов предсказать невозможно
* момент вызова финализатора контролировать невозможно
* если финализатор приводит к блокировке, другие объекты не смогут выполнить финализацию
* финализатор может вообще не запуститься если приложение завершиться аварийно

Чтобы минимизировать отрицательные моменты, финализаторы должны работать быстро, не блокироваться, не ссылаться на
другие финализируемые объекты, не генерировать исключений.

### Отличие от деструкторов

Внешне финализатор схож с деструктором класса, однако в действительности эффект действия и область применения этих
методов существенно различаются. Различие вызвано тем, что момент вызова финализатора, в отличие от деструктора, не
определён жёстко: финализатор всегда вызывается перед уничтожением объекта сборщиком мусора, но момент уничтожения
зависит от режима работы сборщика мусора, объёма доступной оперативной памяти и активности использования памяти
программой. Так, если свободной памяти мало и создание новых объектов происходит постоянно, потребность в сборке мусора
возникает часто и финализатор, соответственно, с высокой вероятностью будет вызван вскоре после прекращения
использования объекта. Если же памяти много, а потребление её программой мало, то от прекращения использования объекта
до сборки мусора (и вызова финализатора) может пройти длительное время. Более того, если памяти много и новые объекты
почти или совсем не создаются, то сборщик мусора может вообще не вызываться, а по завершении программы вся выделенная ей
память будет просто возвращена операционной системе; в этом случае финализатор, возможно, вообще не будет вызван.

[Вернуться в начало](#begin)