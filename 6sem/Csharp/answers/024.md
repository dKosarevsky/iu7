[Вернуться к списку вопросов](../questions.md)

# Вопрос № 24

<div id="begin"></div>
-----------------

## Потоки в C#.

* [Создание потока.](#create)
* [Запуск потока.](#start)
* [Присоединение потока к текущему.](#attach)
* [Типы потоков — разница между фоновыми и основными потоками (background и foreground).](#types)
* [Понятие критической секции.](#critical)
* [Создание критических секций с помощью ключевого слова lock.](#lock)

### Основные понятия

**Процесс ОС** - это выполняющийся экземпляр программы. Содержит её код и контекст выполнения. Если программа - это
набор инструкций, то процесс - это их выполнение и вся связанная с этим информация. Информация эта хранится в памяти
проесса. Такая изоляция позволяет избежать ошибок взаимного влияния различных процессов друг на друга, а также помогает
распределять ресурсы компьютера между процессами. Управлением жизненным циклом процессов и рспределением ресурсов между
ними занимается операционная система.

Процесс обычно состоит из:

- образа исполняемого машинного кода
- ввода/вывода процесса
- стека (статическая память для локальных переменных, аргументов методов/функций и т.д.)
- кучи (динамическая память)
- дескрипторов ресурсов, выделенных ОС для этого процесса (например, файловых дескрипторов)
- атрибутов безопасности: владельца процесса и набора разрешений

**Поток ОС** - это наименьшая единица обработки, исполнение которой может быть назначено ядром ОС. Во многих ОС поток
находится внутри процесса и не может использоваться другими процессами или получать доступ к их ресурсам. Потоки могут
совместно использовать ресурсы одного процесса: код, данные и другие. Аналогия: несколько поваров в кухне одного
ресторана могут готовить ингридиенты для одного блюда и читать рецепты из одной поваренной книги. Но повара разных
ресторанов не пересекаются (конечно, рестораны с общей кухней не в счёт).

**Многозадачность**
Некоторые потоки выполняют непрерывную работу, которая никогда не завершается. Например, отрисовка графического
интерфейса работает всё время, когда включен компьютер. Поток, выполняющий эту задачу, выполняет отрисовку N кадров в
секунду, а всё остальное время не занят. Эти свободные промежутки процессорного времени можно использовать для
выполнения других задач, которое происходит в других потоках других процесов.

Обычно число активных потоков в ОС ПК превышает число ядер процессора на 3 порядка. Параллельное выполнение нескольких
потоков происходит путём временного мультиплексирования: процессор переключается с одного потока на другой. Это
переключение происхдит достаточно часто, чтобы пользователь воспринимао выполнение потоков как одновременное.

Управлять процессом переключения нельзя. Повлиять на него можно лишь задав приоритет потоку. Наивысший приоритет
называют приоритетом реального времени. Это означает, что поток должен обрабатываться так часто, чтобы у пользователя
складывалось ощущение, что он выполняется постоянно.


<div id="create"></div>
-----------------

### Создание потока

Для создания потока нужно создать экземпляр класса `System.Threading.Thread`. Конструктор принимает делегат, ссылающийся
на метод, который будет "функцией main" для этого потока. Выполнение этого потока начнётся с вызова этого метода, и
завершится когда метод будет выполнен.

```cs
class Program 
{
    static void Main()
    {
        var thread = new Thread(ThreadMain);

        Console.WriteLine("Hello from main thread!");
        Console.ReadLine();
    }

    static void ThreadMain(object obj)
    {
        Console.WriteLine("Hello from another thread!");
    }
}
```

<div id="start"></div>
-----------------

### Запуск потока

Запустить выполнение потока можно вызовом метода `Start`.

```cs
class Program 
{
    static void Main()
    {
        var thread = new Thread(ThreadMain);

        thread.Start();

        Console.WriteLine("Hello from main thread!");
        Console.ReadLine();
    }

    static void ThreadMain(object obj)
    {
        Console.WriteLine("Hello from another thread!");
    }
}
```

Перегрузка принимает аргумент типа `object`. Это данные, которые будут поданы на вход методу, ссылку на который подали в
конструктор класса `Thread` при создании экземпляра.

```cs
class Program 
{
    static void Main()
    {
        var thread = new Thread(ThreadMain);

        thread.Start("string parameter");

        Console.WriteLine("Hello from main thread!");
        Console.ReadLine();
    }

    static void ThreadMain(object obj)
    {
        Console.WriteLine("Hello from another thread!");
        Console.WriteLine("My argument is: {0}", obj);
    }
}
```

<div id="attach"></div>
-----------------

### Присоединение потока к текущему

Метод `Join` присоединяет поток к текущему. При этом выполнение текущего потока приостанавливается до тех пор, пока не
будет завершён присоединяемый поток.

```cs
class Program 
{
    static void Main()
    {
        var thread = new Thread(ThreadMain);

        Console.WriteLine("Hello from main thread!");
        thread.Start();
        thread.Join();
        Console.WriteLine("Another thread joined");

        Console.ReadLine();
    }

    static void ThreadMain(object obj)
    {
        Console.WriteLine("Another thread started");
        Thread.Sleep(3000);
        Console.WriteLine("Another thread is about to finish");
    }
}
```

Вывод:

```shell
Hello from main thread!
Another thread started
Another thread is about to finish
Another thread joined
```

Перегрузка метода Join принимает таймаут для этой операции и возвращает булево значение, означающее что присоединение
успешно выполнено раньше, чем истекло время таймаута. Если не передать таймаут в метод Join, то используется бесконечное
значение таймаута. Это значит, что если присоединяемый поток не завершится, то текущий поток будет бесконечно ожидать.

> Рекомендация. По возможности указывайте значение таймаута для присоединения потока, чтобы исключить риск зависания приложения.

### Взаимодействие между потоками

Потоки могут иметь доступ к общим данным:

- захваченные переменные (если тело потока указано как лямбда-выражение)
- статические поля
- поля экземпляра, в метода которого создан поток

Пример: взаимодействие потоков через захваченную переменную.

```cs
int i = 4;
var thread = new Thread(_ => i++);  //  инкремент в другом потоке
i++;    //  инкремент той же переменной в текущем потоке
```

Пример: взаимодействие потоков через статическое поле.

```cs
class A
{
    public static int i;
}

class B
{
    public void CreateThread()
    {
        var thread = new Thread(ThreadMain);
        A.i++;
    }

    private void ThreadMain(object obj)
    {
        A.i++;
    }
}
```

Пример: взаимодействие потоков через поле экземпляра.

```cs
class B
{
    int i = 3;

    public void CreateThread()
    {
        var thread = new Thread(ThreadMain);
        i++;
    }

    private void ThreadMain(object obj)
    {
        i++;
    }
}
```

В приведённых примерах "взаимодействие" между потоками показано условно: они читают и пишут значение одной переменной.
По изменению этого значения они могут наблюдать последствия работы друг друга. Более показательным будет пример с
событийной моделью взаимодействия.

```cs
class AsyncCalculator<TResult>
{
    public event Action<T> CalculateComplete;

    public void Calculate(Func<TResult> fn)
    {
        var thread = new Thread(() => 
        {
            var result = fn();

            CalculateComplete?.Invoke(result)
        });

        thread.Start();
    }
}
```

### Получение ссылки на текущий поток

```cs
var currentThread = Thread.CurrentThread;
```

<div id="types"></div>
-----------------

### Типы потоков — разница между фоновыми и основными потоками (background и foreground)

Основные потоки удерживают процесс выполнения программы от завершения. Процесс выполняется до тех пор, пока выполняется
хотя бы один основной поток.

Фоновые потоки не удерживают процесс от завершения. Как только завершены все основные потоки, программа завершается, не
дожидаясь окончания фоновых потоков.

Свойство `IsBackground` класса `Thread` показывает, является ли поток фоновым. По умолчанию поток создаётся как
основной. Чтобы сделать его фоновым, следует присвоить этому свойству значение `true`.

### Идентификатор и имя потока

Свойство `ManagedThreadId` возвращает целочисленный идентификатор потока, назначаемый средой исполнения. Вы можете
использовать это значение для идентификации потоков.

Свойство `Name` позволяет задать и узнать строковое имя потока. Удобно задать строковые имена потокам для отладки
многопоточного приложения.

### Потокобезопасность кода.

Рассмотрим пример непотокобезопасного кода.

```cs
public class MyList<T>
{
    private const int DefaultCapacity = 4;

    private T[] items = new T[DefaultCapacity];

    public int Count { get; private set; } = 0;

    public T this[int index]
    {
        get { return items[index]; }
        set { items[index] = value; }
    }

    public void Add(T item)
    {
        if (Count >= items.Length)
            Resize(2);

        items[Count] = item;
        Count++;    //  Count = Count + 1
    }

    private void Resize(int quantifier)
    {
        int newSize = quantifier * items.Length;
        T[] newItems = new T[newSize];

        items.CopyTo(newItems, 0);

        this.items = newItems;
    }
}
```

Метод `Add` класса `MyList` содержит ряд проблем при использовании в многопоточной среде. При переключении процессора
между потоками выполнение каждого может быть приостановлено в любом месте этого метода:

- перед считыванием значения `Count`
- перед считыванием значения `items.Length`
- перед их сравнением
- перед вызовом `Resize`
- и т.д.

К каким проблемам это может привести:

1. Поток А остановился перед `Count++`, а поток B выполняет `items[Count - 1] = item`. Результат: добавляли 2 числа, но
   второе записалось в массив поверх первого, а количество всё равно увеличилось на 2. Вместо второго числа будет число
   0 (значение по умолчанию типа int).
2. Поток A прочитал значение Count в инструкции `Count++` и остановился. Поток B после этого прочитал это же значение,
   прибавил единицу и записал в Count. Затем поток A продолжил выполнение: увеличил прочитанное значение на 1 и записал
   в Count. Результат: добавляли 2 элемента, но Count увеличился на 1. Один из элементов недоступен.
3. Поток А заменил массив, а поток B вставил в прежний массив новый элемент.
4. И т.д.

Код для демонстрации проблем с потокобезопасностью класа MyList:

```cs
void ShowMyListSyncProblems()
{
    var list = new MyList<int>();
    var random = new Random();

    var threads = Enumerable.Range(0, 100)
        .Select(_ => new Thread(() =>
        {
            for (int i = 0; i < 1000; i++)
            {
                try
                {
                    list.Add(random.Next(0, 1001));
                }
                catch
                {
                }
            }
        }))
        .ToArray();

    foreach (var thread in threads)
    {
        thread.Start();
    }

    foreach (var thread in threads)
    {
        thread.Join();
    }

    Console.WriteLine("List items count: {0}", list.Count);
}
```

Пояснения к коду:

- создаём 100 потоков
- каждый поток добавляет в список 1000 случайных чисел. Обработка исключений скроет возникающие ошибки
- стартуем все потоки
- присоединяем все потоки
- проверяем, сколько элементов добавились в список. Должно быть 100 000.
- В реальности число будет меньше 100 000. В одном из запусков получилось 96 657.

<div id="critical"></div>
-----------------

### Понятие критической секции

**Критическая секция** - это участок кода, к которому не должен выполняться одновременный доступ более чем из одного
потока.

В примере выше тело метода Add должно быть критической секцией, чтобы класс MyList стал потокобезопасным.

Задача синхронизации потоков - создание критических секций.

Типичные проблемы:

- взаимоблокировки (deadlocks)
- лишние ожидания

<div id="lock"></div>
-----------------

### Создание критических секций с помощью ключевого слова `lock`

Инструкция `lock` создаёт критическую секцию. Зайти в неё можно только в том случае, если никакой другой поток не
находится внутри.

```cs
class A
{
    private readonly object syncRoot = new object();

    public void F()
    {
        lock (syncRoot)
        {

        }
    }
}
```

Объект `syncRoot` в примере идентифицирует критическую секцию.

Один поток может зайти в критическую секцию несколько раз, но после этого он должен выйти из неё ровно такое же число
раз, чтобы считаться вышедшим из неё.

Конструкция lock - синтаксический сахар:

```cs
Monitor.Enter(syncRoot);
try
{

}
finally
{
    Monitor.Exit(syncRoot);
}
```

Порядок входа в критическую секцию не определён. После выхода из неё одного потока зайдёт один из всех скопившихя в
ожидании входа потоков.

### Mutex

Мьютекс — это примитив синхронизации, позволяющий запретить проход других потоков.

```cs
var mutex = new Mutex();

mutex.WaitOne();

//  do some work

mutex.ReleaseMutex();
```

При вызове метода `WaitOne`:

- поток захватит владение мьютексом, если никакой другой поток ещё этого не сделал
- иначе, поток перейдёт в ожидание захвата мьютекса

Перегрузка метода `WaitOne` принимает значение таймаута и возвращает булево значение, означающее, что текущему потоку
удалось захватить мьютекс раньше, чем истёк таймаут.

При вызове метода `ReleaseMutex` текущий поток освобождает мьютекс.

Перегрузка конструктора с булевым параметром позволяет задать признак владения текущего потока созданным мьютексом.

Перегрузка конструктора со строковым параметром позволяет создать системный мьютекс. Системный мьютекс создаётся в ОС и
может быть использован для межпроцессной синхронизации.

[Вернуться в начало](#begin)