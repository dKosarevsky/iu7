[Вернуться к списку вопросов](../questions.md)

<div id="begin"></div>
-----------------

# Вопрос № 12

- [Методы классов](#методы)
- [Переменное число параметров](#переменное-число-параметров)
- [Значения параметров по умолчанию](#значения-параметров-по-умолчанию)
- [Именованные параметры при вызове методов](#именованные-параметры-при-вызове-методов)
- [Ref и out параметры](#ref-и-out-параметры)
- [Перегрузка методов](#перегрузка-методов)
- [Переопределение методов базового класса](#переопределение-методов-базового-класса)
- [Подмена методов базового класса](#подмена-методов-базового-класса)
- [Виртуальные и абстрактные методы](#виртуальные-и-абстрактные-методы)
- [Статические методы](#статические-методы)
- [Свойства](#свойства)
- [Индексаторы](#индексаторы)

## Методы

По сути метод - это именованный блок кода, который выполняет некоторые действия. Общее определение методов выглядит
следующим образом:

    [модификаторы] тип_возвращаемого_значения название_метода ([параметры])
    {
        // тело метода
    }

Модификаторы и параметры необязательны. Например, по умолчанию консольная программа на языке C# должна содержать как
минимум один метод - метод Main, который является точкой входа в приложение:

```cs
static void Main(string[] args)
{
}
```

Ключевое слово static является модификатором. Далее идет тип возвращаемого значения. В данном случае ключевое слово void
указывает на то, что метод ничего не возвращает. Далее идет название метода - Main и в скобках параметры - string[]
args. В фигурные скобки заключено тело метода - все действия, которые он выполняет. В данном случае метод Main пуст, он
не содержит никаких операторов и по сути ничего не выполняет.

### Вызов методов

Для вызова метода указывается его имя, после которого в скобках идут значения для его параметров (если метод принимает
параметры).

    название_метода (значения_для_параметров_метода);

### Возвращение значения

Метод может возвращать значение, какой-либо результат. Если метод имеет любой другой тип, отличный от void, то такой
метод обязан вернуть значение этого типа. Методы имеющие тип возвращаемого значения void - значения не возвращают. Для
этого применяется оператор return, после которого идет возвращаемое значение:

    return возвращаемое значение;

Результат методов, который возвращают значение, мы можно присвоить переменным или использовать иным образом в программе.
Оператор return не только возвращает значение, но и производит выход из метода. Поэтому он должен определяться после
отальных инструкций.

### Сокращенная запись методов

Если метод в качестве тела определяет только одну инструкцию, то мы можно сократить определение метода. Например, есть
метод:

```cs
static void SayHello()
{
    Console.WriteLine("Hello");
}
```

Можно сократить следующим образом:

```cs
static void SayHello() => Console.WriteLine("Hello");
```

### Параметры методов

Параметры позволяют передать в метод некоторые входные данные. Например, определеим метод, который складывает два числа:

```cs
static int Sum(int x, int y)
{
    return x + y;
}
```

Метод Sum имеет два параметра: x и y. Оба параметра представляют тип int. Поэтому при вызове данного метода нам
обязательно надо передать на место этих параметров два числа. Иногда можно встретить такие определения как формальные
параметры и фактические параметры. Формальные параметры - это собственно параметры метода (в данном случае x и y), а
фактические параметры - значения, которые передаются формальным параметрам. То есть фактические параметры - это и есть
аргументы метода.

### Переменное число параметров

С помощью ключевого слова params можно указать параметр метода, принимающий переменное число аргументов. Тип параметра
должен быть одномерным массивом. В объявлении метода после ключевого слова params дополнительные параметры не
допускаются, и в объявлении метода допускается только одно ключевое слово params. Если объявленный тип параметра params
не является одномерным массивом, возникает ошибка компилятора CS0225. При вызове метода с параметром params можно
передать следующие объекты:

- разделенный запятыми список аргументов типа элементов массива;
- массив аргументов указанного типа;
- не передавать аргументы. Если аргументы не отправляются, длина списка params равна нулю.

Пример:

```cs
public static void UseParams(params int[] list)
{
    for (int i = 0; i < list.Length; i++)
    {
        Console.Write(list[i] + " ");
    }
    Console.WriteLine();
}

object[] myObjArray = { 2, 'b', "test", "again" };
UseParams(myObjArray);
```

Вывод:

    2 b test again

### Значения параметров по умолчанию

Необязательные параметры определяются в конце списка параметров после всех обязательных параметров. Если вызывающий
объект предоставляет аргумент для любого из последующих необязательных параметров, он должен содержать аргументы для
всех предыдущих необязательных параметров:

```cs
static int OptionalParam(int x, int y, int z=5, int s=4)
{
    return x + y + z + s;
}
```

Определение каждого необязательного параметра содержит его значение по умолчанию. Если аргумент для параметра не
передается, используется значение по умолчанию. Значением по умолчанию должен быть один из следующих типов выражений:

- константное выражение;
- выражение в форме new ValType(), где ValType — это тип значения, например, enum или struct;
- выражение в форме default(ValType), где ValType — это тип значения.

Так как последние два параметра объявлены как необязательные, то мы можем один из них или оба опустить:

     OptionalParam(2, 3);

Функция вычислит сумму:

    2 + 3 + 5 + 4 // 5 и 4 значения z и s по умолчанию

### Именованные параметры при вызове методов

Именованные аргументы освобождают от необходимости сопоставлять порядок параметров в списках параметров вызванных
методов. Параметр для каждого аргумента можно указать, используя имя параметра. Например, функция, которая выводит
сведения о заказе (имя продавца, номер заказа и наименование товара и т. д.), может вызываться путем передачи аргументов
по позиции в порядке, определяемом функцией.

```cs
static void PrintOrderDetails(string sellerName, int orderNum, string productName)
{
    if (string.IsNullOrWhiteSpace(sellerName))
    {
        throw new ArgumentException(message: "Seller name cannot be null or empty.", paramName: nameof(sellerName));
    }

    Console.WriteLine($"Seller: {sellerName}, Order #: {orderNum}, Product: {productName}");
}

PrintOrderDetails("Gift Shop", 31, "Red Mug");
```

Можно передать передать аргументы в любом порядке:

    PrintOrderDetails(orderNum: 31, productName: "Red Mug", sellerName: "Gift Shop");
    PrintOrderDetails(productName: "Red Mug", sellerName: "Gift Shop", orderNum: 31);

Именованные аргументы при использовании с позиционными аргументами допустимы при условии, что:

- за ними не следуют позиционные аргументы:

      PrintOrderDetails("Gift Shop", 31, productName: "Red Mug");
- начиная с C# 7.2, они используются в правильной позиции. В примере ниже параметр orderNum находится в правильной
  позиции, но не имеет явно заданного имени.

       PrintOrderDetails(sellerName: "Gift Shop", 31, productName: "Red Mug");

Позиционные аргументы после внеочередных именованных аргументов недопустимы.

    // This generates CS1738: Named argument specifications must appear after all fixed arguments have been specified.
    PrintOrderDetails(productName: "Red Mug", 31, "Gift Shop");

### Ref и out параметры

##### Модификатор ref

При передаче параметров по ссылке перед параметрами используется модификатор ref:

```cs
// параметр x передается по ссылке
static void Addition(ref int x, int y)
{
    x += y;
}

Addition(ref x, y); // вызов метода
```

При передаче параметра по ссылке метод получает адрес переменной в памяти. И, таким образом, если в методе изменяется
значение параметра, передаваемого по ссылке, то также изменяется и значение переменной, которая передается на его место.

##### Модификатор out

Переменные, передаваемые в качестве аргументов out, не требуется инициализировать перед передачей в вызове метода. Но
перед передачей управления из вызванного метода он должен присвоить значение:

```cs
void OutArgExample(out int number)
{
    number = 44;
}
```

##### Модификатор in

Модификатор in указывает, что данный параметр будет передаваться в метод по ссылке, однако внутри метода его значение
параметра нельзя будет изменить.

```cs
static void GetData(in int x, int y, out int area, out int perim)
{
    // x = x + 10; нельзя изменить значение параметра x
    y = y + 10;
    area = x * y;
    perim = (x + y) * 2;
}
```

В данном случае через параметры x и y в метод передаются значения, но в самом методе можно изменить только значение
параметра y, так как параметр x указан с модификатором in.

Ключевые слова ref, out и in используются как при определении метода, так и при его вызове. Ключевые слова in, ref и out
запрещено использовать для следующих типов методов.

- Асинхронные методы, которые определяются с помощью модификатора async.
- Методы итератора, которые включают оператор yield return или yield break.

### Перегрузка методов

Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. В зависимости от имеющихся
параметров применять определенную версию метода. Такая возможность еще называется перегрузкой методов (method
overloading). Иначе говоря перегрузка - возможность создавать в классе несколько методов с одним и тем же именем, но
разной сигнатурой. Сигнатура складывается из следующих аспектов:

- Имя метода
- Количество параметров
- Типы параметров
- Порядок параметров
- Модификаторы параметров

Для перегрузки методы должны отличаться по:

- Количеству параметров
- Типу параметров
- Порядку параметров
- Модификаторам параметров

Например:

```cs
class Calculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }
    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
    public int Add(int a, int b, int c, int d)
    {
        return a + b + c + d;
    }
    public double Add(double a, double b)
    {
        return a + b;
    }
}
```

Здесь представлены четыре разных версии метода Add, то есть определены четыре перегрузки данного метода. Первые три
версии метода отличаются по количеству параметров. Четвертая версия совпадает с первой по количеству параметров, но
отличается по их типу. При этом достаточно, чтобы хотя бы один параметр отличался по типу. Поэтому это тоже допустимая
перегрузка метода Add. То есть мы можем представить сигнатуры данных методов следующим образом:

```cs
    Add(int, int)
    Add(int, int, int)
    Add(int, int, int, int)
    Add(double, double)
```

Тип возвращаемого значения частью сигнатуры не является.

Ключевые слова in, ref и out не считаются частью сигнатуры метода для разрешения перегрузки. Таким образом, методы не
могут быть перегружены, если единственное различие состоит в том, что один метод принимает аргумент ref или in, а другой
— out. Следующий код, например, компилироваться не будет:

```cs
class CS0663_Example
{
    // Compiler error CS0663: "Cannot define overloaded
    // methods that differ only on ref and out".
    public void SampleMethod(out int i) { }
    public void SampleMethod(ref int i) { }
}
```

Перегрузка допустима, если один метод принимает аргумент ref, in или out, а другой не использует ни один из этих
модификаторов, как показано ниже.

```cs
class OutOverloadExample
{
    public void SampleMethod(int i) { }
    public void SampleMethod(out int i) => i = 5;
}
```

#### Переопределение методов базового класса

Класс-наследник может переопределять методы и свойства базового класса. Методы и свойства, которые необходимо сделать
доступными для переопределения, в базовом классе помечается модификатором virtual. Такие методы и свойства называют
виртуальными. Чтобы переопределить метод в классе-наследнике, этот метод определяется с модификатором override.
Переопределенный метод в классе-наследнике должен иметь тот же набор параметров, что и виртуальный метод в базовом
классе. Рассмотрим следующие классы:

```cs
class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual void Display()
    {
        Console.WriteLine(Name);
    }
}
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company) : base(name)
    {
        Company = company;
    }
}
```

Чтобы сделать метод Display доступным для переопределения, этот метод определен с модификатором virtual. Поэтому
возможно переопределить этот метод. Переопределение не является обязательнным для методов с модификатором virtual.
Например в этом случае объекты Employee будут использовать реализацию метода Display из класса Person:

```cs
static void Main(string[] args)
{
    Person p1 = new Person("Bill");
    p1.Display(); // вызов метода Display из класса Person

    Employee p2 = new Employee("Tom", "Microsoft");
    p2.Display(); // вызов метода Display из класса Person
}
```

Для переопределения метода в классе-наследнике определяется метод с модификатором override, который имеет то же самое
имя и набор параметров:

```cs
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }

    public override void Display()
    {
        Console.WriteLine($"{Name} работает в {Company}");
    }
}

static void Main(string[] args)
{
    Person p1 = new Person("Bill");
    p1.Display(); // вызов метода Display из класса Person

    Employee p2 = new Employee("Tom", "Microsoft");
    p2.Display(); // вызов метода Display из класса Employee
}
```

При переопределении виртуальных методов следует учитывать ряд ограничений:

- Виртуальный и переопределенный методы должны иметь один и тот же модификатор доступа. То есть если виртуальный метод
  определен с помощью модификатора public, то и переопредленный метод также должен иметь модификатор public.
- Нельзя переопределить или объявить виртуальным статический метод.

Также можно запретить переопределение методов и свойств. В этом случае их надо объявлять с модификатором sealed. При
создании методов с модификатором sealed надо учитывать, что sealed применяется в паре с override, то есть только в
переопределяемых методах.

#### Подмена методов базового класса

Фактически сокрытие представляет определение в классе-наследнике метода или свойства, которые соответствует по имени и
набору параметров методу или свойству базового класса. Для сокрытия членов класса применяется ключевое слово new.
Сокрытие полезно в случаях, когда метод в базовом классе не является виртуальным, его нельзя переопределить без
изменения базового класса, но можно воспользоваться сокрытием, чтобы определить нужный нам функционал.

Основное различие между данными методами состоит в том, что переопределение методов предоставялет полиморфное поведение,
в то время как скокрытие методов - нет.

Переопределение:

```cs
class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }
    public virtual void Display()
    {
        Console.WriteLine(Name);
    }
}
class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
}

Person tom = new Employee("Tom", "Microsoft");
tom.Display();      // Tom работает в Microsoft
```

При вызове tom.Display() выполняется реализация метода Display из класса Employee. Хотя переменной tom - Person. Для
работы с виртуальными методами компилятор формирует таблицу виртуальных методов (Virtual Method Table или VMT). В нее
записывается адреса виртуальных методов. Для каждого класса создается своя таблица. Когда создается объект класса, то
компилятор передает в конструктор объекта специальный код, который связывает объект и таблицу VMT. А при вызове
виртуального метода из объекта берется адрес его таблицы VMT. Затем из VMT извлекается адрес метода и ему передается
управление. То есть процесс выбора реализации метода производится во время выполнения программы. Собственно так и
выполняется виртуальный метод. Следует учитывать, что так как среде выполнения вначале необходимо получить из таблицы
VMT адрес нужного метода, то это немного замедляет выполнение программы.

Сокрытие:

```cs
class Person
{
    public string Name { get; set; }
    public Person(string name)
    {
        Name = name;
    }

    public void Display()
    {
        Console.WriteLine(Name);
    }
}

Person tom = new Employee("Tom", "Microsoft");
tom.Display();      // Tom

class Employee : Person
{
    public string Company { get; set; }
    public Employee(string name, string company)
        : base(name)
    {
        Company = company;
    }
    public new void Display()
    {
        Console.WriteLine($"{Name} работает в {Company}");
    }
}
```

Переменная tom представляет тип Person, но хранит ссылку на объект Employee. Однако при вызове метода Display будет
выполняться та версия метода, которая определена именно в классе Person, а не в классе Employee. Класс Employee никак не
переопределяет метод Display, унаследованный от базового класса, а фактически определяет новый метод. Поэтому при вызове
tom.Display() вызывается метод Display из класса Person.

#### Виртуальные и абстрактные методы

Виртуальные методы были рассмотрены выше. Все абстрактные методы - виртуальные методы. Абстрактный метод может быть
объявлен только в абстрактном классе. Создание объекта абстрактного класса - невозможно. При определении абстрактных
классов используется ключевое слово abstract:

```cs
abstract class Human
{
    public int Length { get; set; }
    public double Weight { get; set; }
}
```

Абстрактными так же могут быть:

- Методы
- Свойства
- Индексаторы
- События

Абстрактные члены классов не должны иметь модификатор private. При этом производный класс обязан переопределить и
реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в
производном классе такой метод или свойство также объявляются с модификатором override (как и при обычном
переопределении виртуальных методов и свойств). Абстрактные члены также, как и виртуальные, являются частью полиморфного
интерфейса. Но если в случае с виртуальными методами мы говорим, что класс-наследник наследует реализацию, то в случае с
абстрактными методами наследуется интерфейс, представленный этими абстрактными методами. Производный класс обязан
реализовать все абстрактные члены базового класса либо сам должен быть абстрактным.

#### Статические методы

Статические методы - это методы принадлежащие типу, а не объекту. Для вызова статического метода не нужно создавать
объект типа, в котором данный метод определён. Статический метод не может обращаться к нестатическим аттрибутам класса.
Статические методы невозможно переопределить, но можно сокрыть при помощи ключевого слова new, аналогично нестатическим
методам.

#### Свойства

Свойства - специальные методы доступа, которые называют свойства. Они обеспечивают простой доступ к полям классов и
структур, узнать их значение или выполнить их установку.

```cs
class Person
{
    private string name;

    public string Name
    {
        get
        {
            return name;
        }

        set
        {
            name = value;
        }
    }
}
```

Здесь есть закрытое поле name и есть общедоступное свойство Name. Хотя они имеют практически одинаковое название за
исключением регистра, но это не более чем стиль, названия у них могут быть произвольные и не обязательно должны
совпадать.

Через это свойство можно управлять доступом к переменной name. Стандартное определение свойства содержит блоки get и
set. В блоке get мы возвращаем значение поля, а в блоке set устанавливаем. Параметр value представляет передаваемое
значение.

Данное свойство может быть использовано следующим образом:

```cs
Person p = new Person();

// Устанавливаем свойство - срабатывает блок Set
// значение "Tom" и есть передаваемое в свойство value
p.Name = "Tom";

// Получаем значение свойства и присваиваем его переменной - срабатывает блок Get
string personName = p.Name; 
```

Свойства могут содержать дополнительный код. Например проверки:

```cs
class Person
{
    private int age;

    public int Age
    {
        set
        {
            if (value < 18)
            {
                Console.WriteLine("Возраст должен быть больше 17");
            }
            else
            {
                age = value;
            }
        }
        get { return age; }
    }
}
```

Свойства так же могут быть автоматическими. Они имеют сокращенное объявление:

```cs
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
     
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```

Свойства могут так же быть абстрактными или виртуальными. Так же могут быть сокрыты при помощи new.

#### Индексаторы

Индексаторы позволяют индексировать экземпляры класса или структуры точно так же, как и массивы. Индексированное
значение можно задавать или получать без явного указания типа или экземпляра элемента. Индексаторы действуют как
свойства, за исключением того, что их акцессоры принимают параметры.

```cs
сlass SampleCollection<T>
{
    private T[] arr = new T[100];

    // Определение индексера, позволяющее использовать нотацию []
     public T this[int i]
    {
        get { return arr[i]; }
        set { arr[i] = value; }
    }
}

class Program
{
    static void Main()
    {
        var stringCollection = new SampleCollection<string>();
        stringCollection[0] = "Hello, World";
        Console.WriteLine(stringCollection[0]);
    }
}
```

[Вернуться в начало](#begin)