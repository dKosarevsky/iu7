[Вернуться к списку вопросов](../questions.md)

<div id="begin"></div>
-----------------

# Вопрос № 4

* Конструкции языка.
* Ветвления.
* Циклы.

Условные конструкции — один из базовых компонентов многих языков программирования, которые направляют работу программы
по одному из путей в зависимости от определенных условий. В языке C# используются следующие условные конструкции:
`if..else` и `switch..case`

### Конструкция `if/else`

Конструкция `if/else` проверяет истинность некоторого условия и в зависимости от результатов проверки выполняет
определенный код:

```cs
int num1 = 8;
int num2 = 6;
if(num1 > num2)
{
    Console.WriteLine($"Число {num1} больше числа {num2}");
}
```

После ключевого слова `if` ставится условие. И если это условие выполняется, то срабатывает код, который помещен далее в
блоке `if` после фигурных скобок. В качестве условий выступают ранее рассмотренные операции сравнения.

В данном случае у нас первое число больше второго, поэтому выражение `num1 > num2` истинно и возвращает `true`,
следовательно, управление переходит к строке `Console.WriteLine("Число {num1} больше числа {num2}");`

Но что, если мы захотим, чтобы при несоблюдении условия также выполнялись какие-либо действия? В этом случае мы можем
добавить блок `else`:

```cs
int num1 = 8;
int num2 = 6;
if(num1 > num2)
{
    Console.WriteLine($"Число {num1} больше числа {num2}");
}
else
{
    Console.WriteLine($"Число {num1} меньше числа {num2}");
}
```

Но при сравнении чисел мы можем насчитать три состояния: первое число больше второго, первое число меньше второго и
числа равны. Используя конструкцию `else if`, мы можем обрабатывать дополнительные условия:

```cs
int num1 = 8;
int num2 = 6;
if(num1 > num2)
{
    Console.WriteLine($"Число {num1} больше числа {num2}");
}
else if (num1 < num2)
{
    Console.WriteLine($"Число {num1} меньше числа {num2}");
}
else
{
    Console.WriteLine("Число num1 равно числу num2");
}
```

Также мы можем соединить сразу несколько условий, используя логические операторы:

```cs
int num1 = 8;
int num2 = 6;
if (num1 > num2 && num1==8)
{
    Console.WriteLine($"Число {num1} больше числа {num2}");
}
```

В данном случае блок `if` будет выполняться, если `num1 > num2` равно `true` и `num1 == 8` равно `true`.

### Конструкция `switch`

Конструкция `switch/case` аналогична конструкции `if/else`, так как позволяет обработать сразу несколько условий:

```cs
Console.WriteLine("Нажмите Y или N");
string selection = Console.ReadLine();
switch (selection)
{
    case "Y":
        Console.WriteLine("Вы нажали букву Y");
        break;
    case "N":
        Console.WriteLine("Вы нажали букву N");
        break;
    default:
        Console.WriteLine("Вы нажали неизвестную букву");
        break;
}
```

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно
сравнивается со значениями, помещенными после оператора `case`. И если совпадение будет найдено, то будет выполняться
определенный блок `case`. В конце каждого блока case должен ставиться один из операторов перехода: `break`, `goto case`,
`return` или `throw`. Как правило, используется оператор `break`. При его применении другие блоки `case` выполняться не
будут. Однако если мы хотим, чтобы, наоборот, после выполнения текущего блока case выполнялся другой блок `case`, то мы
можем использовать вместо `break` оператор `goto case`:

```cs
int number = 1;
switch (number)
{
    case 1:
        Console.WriteLine("case 1");
        goto case 5; // переход к case 5
    case 3:
        Console.WriteLine("case 3");
        break;
    case 5:
        Console.WriteLine("case 5");
        break;
    default:
        Console.WriteLine("default");
        break;
}
```

Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок `default`, как в
примере выше. Применение оператора `return` позволит выйти не только из блока case, но и из вызывающего метода. То есть,
если в методе `Main` после конструкции `switch…case`, в которой используется оператор `return`, идут какие-либо
операторы и выражения, то они выполняться не будут, а метод `Main` завершит работу. Оператор throw применяется для
выброса ошибок и будет рассмотрен в одной из следующим тем.

#### Тернарная операция

Тернарная операция имеет следующий синтаксис: [первый операнд - условие] ? [второй операнд] : [третий операнд]. Здесь
сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно
true, то возвращается второй операнд; если условие равно `false`, то третий. Например:

```cs
int x=3;
int y=2;
Console.WriteLine("Нажмите + или -");
string selection = Console.ReadLine();
 
int z = selection=="+"? (x+y) : (x-y);
Console.WriteLine(z);
```

Здесь результатом тернарной операции является переменная `z`. Если мы выше вводим `+`, то `z` будет равно второму
операнду

- `(x+y)`. Иначе `z` будет равно третьему операнду.

### Циклы

Циклы являются управляющими конструкциями, позволяя в зависимости от определенных условий выполнять некоторое действие
множество раз. В `C#` имеются следующие виды циклов:

* `for`
* `foreach`
* `while`
* `do...while`

#### Цикл `for`

Цикл `for` имеет следующее формальное определение:

    for ([инициализация счетчика]; [условие]; [изменение счетчика])
    {
        // действия
    }

Рассмотрим стандартный цикл `for`:

```cs
for (int i = 0; i < 9; i++)
{
    Console.WriteLine($"Квадрат числа {i} равен {i*i}");
}
```

Первая часть объявления цикла - `int i = 0` - создает и инициализирует счетчик `i`. Счетчик необязательно должен
представлять тип `int`. Это может быть и другой числовой тип, например, `float`. И перед выполнением цикла его значение
будет равно 0. В данном случае это то же самое, что и объявление переменной.

Вторая часть — условие, при котором будет выполняться цикл. Пока условное выражение возвращает true, будет выполняться
цикл. В данном случае цикл будет выполняться, пока счетчик i не достигнет 9.

И третья часть — приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать:
`i--`.

В итоге блок цикла сработает 9 раз, пока значение i не станет равным 9. И каждый раз это значение будет увеличиваться на

1.

Нам необязательно указывать все условия при объявлении цикла. Например, мы можем написать так:

```cs
int i = 0;
for (; ;)
{
    Console.WriteLine($"Квадрат числа {++i} равен {i * i}");
}
```

Формально определение цикла осталось тем же, только теперь блоки в определении у нас пустые: `for (; i <;)`. У нас нет
инициализированной переменной-счетчика, нет условия, поэтому цикл будет работать вечно — бесконечный цикл.

Мы также можем опустить ряд блоков:

```cs
int i = 0;
for (; i<9;)
{
    Console.WriteLine($"Квадрат числа {++i} равен {i * i}");
}
```

Этот пример по сути эквивалентен первому примеру: у нас также есть счетчик, только создан он вне цикла. У нас есть
условие выполнения цикла. И есть приращение счетчика уже в самом блоке for.

#### Цикл do

В цикле `do` сначала выполняется код цикла, а потом происходит проверка условия в инструкции `while`. И пока это условие
истинно, цикл повторяется. Например:

```cs
int i = 6;
do
{
    Console.WriteLine(i);
    i--;
}
while (i > 0);
```

Здесь код цикла сработает 6 раз, пока i не станет равным нулю. Но важно отметить, что цикл `do` гарантирует хотя бы
единократное выполнение действий, даже если условие в инструкции `while` не будет истинно. То есть мы можем написать:

```cs
int i = -1;
do
{
    Console.WriteLine(i);
    i--;
}
while (i > 0);
```

Хотя у нас переменная i меньше 0, цикл все равно один раз выполнится.

#### Цикл while

В отличие от цикла `do` цикл `while` сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла
выполняется:

```cs
int i = 6;
while (i > 0)
{
    Console.WriteLine(i);
    i--;
}
```

#### Операторы continue и break

Иногда возникает ситуация, когда требуется выйти из цикла, не дожидаясь его завершения. В этом случае мы можем
воспользоваться оператором `break`. Например:

```cs
for (int i = 0; i < 9; i++)
{
    if (i == 5)
        break;
    Console.WriteLine(i);
}
```

Хотя в условии цикла сказано, что цикл будет выполняться, пока счетчик i не достигнет значения 9, в реальности цикл
сработает 5 раз. Так как при достижении счетчиком i значения 5, сработает оператор break, и цикл завершится.

    0
    1
    2
    3
    4

Теперь поставим себе другую задачу. А что если мы хотим, чтобы при проверке цикл не завершался, а просто пропускал
текущую итерацию. Для этого мы можем воспользоваться оператором `continue`:

```cs
for (int i = 0; i < 9; i++)
{
    if (i == 5)
        continue;
    Console.WriteLine(i);
}
```

В этом случае цикл, когда дойдет до числа 5, которое не удовлетворяет условию проверки, просто пропустит это число и
перейдет к следующей итерации:

    0
    1
    2
    3
    4
    6
    7
    8

#### Перебор массивов. Цикл foreach

Цикл `foreach` предназначен для перебора элементов в контейнерах, в том числе в массивах. Формальное объявление цикла
`foreach`:

```cs
foreach (тип_данных название_переменной in контейнер)
{
    // действия
}
```

Например:

```cs
int[] numbers = new int[] { 1, 2, 3, 4, 5 };
foreach (int i in numbers)
{
    Console.WriteLine(i);
}
```

Здесь в качестве контейнера выступает массив данных типа `int`. Поэтому мы объявляем переменную с типом `int`

Подобные действия мы можем сделать и с помощью цикл `for`:

```cs
int[] numbers = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i < numbers.Length; i++)
{
    Console.WriteLine(numbers[i]);
}
```

В то же время цикл for более гибкий по сравнению с `foreach`. Если `foreach` последовательно извлекает элементы
контейнера и только для чтения, то в цикле `for` мы можем перескакивать на несколько элементов вперед в зависимости от
приращения счетчика, а также можем изменять элементы:

```cs
int[] numbers = new int[] { 1, 2, 3, 4, 5 };
for (int i = 0; i < numbers.Length; i++)
{
    numbers[i] = numbers[i] * 2;
    Console.WriteLine(numbers[i]);
}
```

[Вернуться в начало](#begin)